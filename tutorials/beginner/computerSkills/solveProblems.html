<!DOCTYPE=html>

<html>

<head>
    <title>solving your problems</title>
	<link rel="stylesheet" href="/styles/styles_tutorial.css">
</head>

<body>

	<header>
		<h1> How to Solve Your Problems </h1>
	</header>

	<nav>
		<a href="./tableOfContents.html">back</a>
	</nav>

	<article>
		<p>
			The most important skill a programmer can have is being comfortable with the unknown. 
			This trait is especially important for beginners because the barrier to entry for programming high.
			It's common to feel overwhelmed when encountering something new, and this causes many
			new programmers to quit because they feel incapable of learning all that they need to know.
			When starting my programming journey I had quit many times, but I kept coming back.
			With each attempt I was able to push further than before and gain a greater sense of self confidence. <br><br>

			This chapter will cover the strategy I use to learn new programming concepts quickly.
			This method is a three step process that can be used for any sized project (even ones not related to programming).
		</p>
	</article>

	<main>
		<section>
			<h2>Step 1: Understanding The Problem</h2>
			<p> 
				Whether it be learning how to implement an algorithm or the syntax of a programming language, the first 
				step to achieving your goal is to gather a complete understanding of what you want to accomplish.
				If you only have a vague idea of what you want then you will need to do research to make that
				idea more concrete. The goal of this step is to identify gaps in knowledge and to build awareness of all the
				options available. For me, this is done primarily as described by the two methods below.
			</p>

			<h3>Method 1: Taking in Information Pertaining to The Topic</h3>
			<p> 
				During this phase, your goal is to answer clarification questions: what is ___ , how do I ___ , how does ___
				work. This part of the process is usually dry, and your time should be centered around looking up jargon, reading
				documentation, and reading from books and sites related to your topic. I often find myself
				jumping between reading and making test files; I practice implementing what I read to internalize what I have learned.   
			</p>

			<h3>Method 2: Look at Solution Examples </h3>
			
			<! explain how examples cause you to learn through experimentation and play. What does that look like?>

			<p>
				Often times, what you want to accomplish has already been done before. I don't condone copying 
				what others have done (please don't!), but I do think that looking at examples is a helpful tool. What makes examples so powerful is 
				the ability to build an intuition for how a solution works through experimentation and play.
				Another reason is the exposure to varying solutions for the same problem. This is critical; because you are no longer restricted to
				solutions inline with your own thought process, you will be provided new angles to attack problem from that you hadn't thought of before
				- often times this new perspective can be applied to new problems in the future. Just be careful because not all solutions
				that you find will be good. While this method is a powerful learning tool, there is potential to use this as a
				crutch, preventing you from learning if you rely on others to do all the work for you. 
			</p>
		</section>

		<section>
			<h2>Step 2: Break The Problem Into Manageable Chunks </h2>
			<! this is for beginners. They might not know what functions or encapsulation is. Link those words with
				corresponding tutorials that explain those concepts>
			<p> 
				Do you know how to eat an elephant? The answer to this philosophical conundrum is to eat it one bite at a time.
				Anything sufficiently complicated will always be difficult to implement. Unless you are able to break down the problem 
				into a series of simpler and manageable pieces, it might be you that ends up getting eaten.
				This is one of the biggest problems I faced when I first started programming. I either gave up before my project was completed,
				or I was too disorganized; this resulted in partial solutions, or a code base made of tangled spaghetti madness!
				If you want to avoid a mess of dependencies and being pigeon holed into an overly complicated solution, then the key is to identify
				how you can break up your project into smaller pieces. This can be done with functions or encapsulation, but understand that the
				over use of those two can lead to fragmentation and introduce un-needed complexity. I don't have any concrete rules to follow, but 
				over time you will build an intuition for how to group things into logical blocks and identifying pieces that can be worked on separately 
				from the main program.
			</p>
		</section>

		<section>
			<h2>Step 3: Work On Each Piece Separately And Slowly Bring Things Together</h2>
			<p>
				In the previous step, we saw that it's important to break down a project into manageable pieces.
				These mini sections give you a foothold to write programs that are simple. After you have the pieces 
				created, you can bring them together (like pieces of a puzzle) to create the image of your final product.
				By working on things separately, you are more able to test if each piece is working properly - if you do them
				all together, an error occurring in one part of your project may have its roots elsewhere 
				(it's difficult to diagnose bugs that cause problems later down the line). Keeping the parts separate ensures that
				problems are localized and isolable. Once you can confirm that a portion of the code is working properly you may
				integrate it into the rest of your project.
			</p>
		</section>

		<section>
			<h2>Things to Keep in Mind</h2>
			<p>
				As you complete work, it is important to document all that you do. This is beneficial for several reasons.
				The first is being able to identify what has already been completed and what you have left to work on.
				Also, if you need to go back to your project in the future, documentation aids in re-learning the inner-workings
				of your program (trust me, you will forget what your code does - even if you wrote it this morning!). 
				Lastly, documentation serves as a record for others. If you document well, people have the ability to see your thought process,
				employers will notice you as a more capable candidate for their company, and other programmers will love you forever if
				you make it clear what your code is doing. Always remember to document everything, 
				for getting into the habit now will serve you well going into the future. 
			</p>
		</section>
	</main>
	
</body>

</html>
